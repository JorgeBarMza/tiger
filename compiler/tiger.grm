structure A =  Absyn
%%
%term
    EOF 
  | ID of string
  | INT of int | STRING of string 
  | COMMA | COLON | SEMICOLON | LPAREN | RPAREN | LBRACK | RBRACK 
  | LBRACE | RBRACE | DOT 
  | PLUS | MINUS | TIMES | DIVIDE | EQ | NEQ | LT | LE | GT | GE
  | AND | OR | ASSIGN
  | ARRAY | IF | THEN | ELSE | WHILE | FOR | TO | DO | LET | IN | END | OF 
  | BREAK | NIL
  | FUNCTION | VAR | TYPE 
  | UMINUS | ELSEPRE | NONMUTREC

%nonterm  exp | program of A.exp | decs | dec | tydec | tydecs | vardec | fundec | fundecs| ty | tyfields | tyfieldsP | lvalue | unit | negation
  | comparison | arithmetic | boolcomp | expP | record | recP | array | assignment | ifThenElse
  | ifThen | letloop | expseq | args | whileloop | forloop | lval | sequence | funCall

%pos int
%verbose
%start program
%eop EOF
%noshift EOF

(* Precedences *)
%left NONMUTREC
%left FUNCTION TYPE
%nonassoc ELSEPRE
%nonassoc ELSE
%nonassoc ASSIGN
%left OF DO
%left AND OR
%nonassoc EQ NEQ GT LT LE GE
%left PLUS MINUS
%left TIMES DIVIDE
%left UMINUS

%name Tiger

%keyword WHILE FOR TO BREAK LET IN END FUNCTION VAR TYPE ARRAY IF THEN ELSE 
	DO OF NIL

%prefer THEN ELSE LPAREN

%value ID ("bogus")
%value INT (1)
%value STRING ("")

%%

(* Grammar definition *)

program	: exp (exp)

exp: NIL (A.NilExp) 
  | sequence (sequence)
  | lvalue (lvalue)
  | INT (A.IntExp(INT))
  | STRING (A.StringExp(STRING,STRINGleft))
  | negation (negation)
  | arithmetic (arithmetic)
  | comparison (comparison)
  | boolcomp (boolcomp)
  | record (record)
  | array (array)
  | assignment (assignment)
  | ifThenElse (ifThenElse)
  | ifThen (ifThen)
  | whileloop (whileloop)
  | forloop (forloop)
  | BREAK (A.BreakExp(BREAKleft))
  | unit (unit)
  | funCall (funCall)
  | letloop (letloop)

expP: exp SEMICOLON expP (A.SeqExp((exp, expleft)::expP))
  | exp ([(exp, expleft)])

expseq: expP (expP) 
  | (A.NilExp)

sequence: LPAREN expP RPAREN (expP)

args: exp COMMA args (exp::args)  
  | exp ([exp])
  | ([])

arithmetic: exp PLUS exp (A.OpExp(exp1, A.PlusOp, exp2, PLUSleft))
  | exp MINUS exp (A.OpExp(exp1, A.MinusOp, exp2, MINUSleft))
  | exp TIMES exp (A.OpExp(exp1, A.TimesOp, exp2, TIMESleft))
  | exp DIVIDE exp (A.OpExp(exp1, A.DivideOp, exp2, DIVIDEleft))

comparison: exp EQ exp (A.OpExp(exp1, A.EqOp, exp2, EQleft))
  | exp NEQ exp (A.OpExp(exp1, A.NeqOp, exp2, NEQleft))
  | exp LT exp (A.OpExp(exp1, A.LtOp, exp2, LTleft))
  | exp LE exp (A.OpExp(exp1, A.LeOp, exp2, LEleft))
  | exp GT exp (A.OpExp(exp1, A.GtOp, exp2, GTleft))
  | exp GE exp (A.OpExp(exp1, A.GeOp, exp2, GEleft))

boolcomp: exp AND exp (A.IfExp(exp1, exp2, 0, ANDleft))
  | exp OR exp (A.IfExp(exp1, 1, exp2, ORleft))

negation: MINUS exp (A.OpExp(0,A.MinusOp,exp,MINUSleft))

unit: LPAREN RPAREN (A.NilExp)

record: ID LBRACE ID EQ exp recP RBRACE (A.RecordExp((Symbol.symbol(ID1), exp, ID1left)::recP, Symbol.symbol(ID2)))

recP: COMMA ID EQ exp recP ((Symbol.symbol(ID), exp, IDleft)::recP) 
  | ([])

array: ID LBRACK exp RBRACK OF exp (A.ArrayExp(Symbol.symbol(ID), exp1, exp2, IDleft))

decs: dec decs (dec::decs)
  | dec ([dec])

dec: tydecs (A.TypeDec(tydecs))
  | vardec (vardec)
  | fundecs (A.FunctionDec(fundecs))

tydecs: tydec tydecs (tydec::tydecs)
  | tydec %prec NONMUTREC ([tydec])

fundecs: fundec fundecs (fundec::fundecs)
  | fundec %prec NONMUTREC ([fundec])

tydec: TYPE ID EQ ty ((Symbol.symbol(ID), ty, TYPEleft))

ty: ID (A.NameTy(Symbol.symbol(ID), IDleft))
  | LBRACE tyfields RBRACE (tyfields)
  | ARRAY OF ID (A.NameTy(Symbol.symbol(ID), ARRAYleft))

tyfields: ([])
  | ID COLON ID tyfieldsP ((Symbol.symbol(ID1), ref true, Symbol.symbol(ID2), COLONleft)::tyfieldsP)

tyfieldsP: ([]) 
  | COMMA ID  COLON ID tyfieldsP ((Symbol.symbol(ID1), ref true, Symbol.symbol(ID2), COMMAleft)::tyfieldsP)

vardec: VAR ID ASSIGN exp (A.VarDec(Symbol.symbol(ID), ref true, exp, VARleft))
  | VAR ID COLON ID ASSIGN exp (A.VarDec(Symbol.symbol(ID1), ref true, (Symbol.symbol(ID2), ID2left), exp, VARleft))

fundec: FUNCTION ID LPAREN tyfields RPAREN EQ exp ((Symbol.symbol(ID), tyfields, NONE, exp, FUNCTIONleft))
  | FUNCTION ID LPAREN tyfields RPAREN COLON ID EQ exp ((Symbol.symbol(ID1), tyfields, (Symbol.symbol(ID2), ID2left), exp, FUNCTIONleft))

lvalue: ID (A.SimpleVar(Symbol.symbol(ID), IDleft)) 
  | lval (lval)

lval: ID DOT ID (A.FieldVar(Symbol.symbol(ID1), Symbol.symbol(ID2), ID1left))
  | lval DOT ID (A.FieldVar(lval, Symbol.symbol(ID), DOTleft))
  | ID LBRACK exp RBRACK (A.SubscriptVar(Symbol.symbol(ID), exp, IDleft))
  | lval LBRACK exp RBRACK (A.SubscriptVar(lval, exp, LBRACKleft))

funCall: ID LPAREN args RPAREN (A.CallExp(Symbol.symbol(ID), args, IDleft))

assignment: lvalue ASSIGN exp (A.AssignExp(lvalue, exp, ASSIGNleft))

ifThenElse: IF exp THEN exp ELSE exp (A.IfExp(exp1, exp2, exp3, IFleft))

ifThen: IF exp THEN exp %prec ELSEPRE (A.IfExp(exp1, exp2, NONE, IFleft))

whileloop: WHILE exp DO exp (A.WhileExp(exp1, exp2, WHILEleft))

forloop: FOR ID ASSIGN exp TO exp DO exp (A.ForExp(Symbol.symbol(ID), ref true, exp1, exp2, exp3, FORleft))

letloop: LET decs IN expseq END (A.LetExp(decs, expseq, LETleft))